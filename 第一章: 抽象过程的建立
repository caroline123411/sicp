John在关于人的理解力的文章中说过， 人类发挥思想的作用，超越简单想法的方法一般有三种： 
1. 把几个简单的想法组合起来，从而形成复杂的想法； 
2. 挑出两个不同的想法，或简单或复杂，把他们放在一起比较，从而找出他们之间的联系；
3. 把一些想法从真实世界中其他的想法中抽离出来，形成一般的规律和观点，我们叫抽象。

我们将要学习“计算过程”这个概念。计算过程是居住在计算机上的抽象物种。随着它们的演化，流程操纵其他称为数据的抽象事物。流程的演变由称为“程序”的一组规则模式指导。人们创建程序去影响计算过程。实际上，我们用我们的法术召唤计算机的精神。

事实上，计算过程非常像巫师对精神的想法，他不能被看见，被触摸到。他不是由具体的事物组成的，然而它又真实的存在。它能完成智能工作，它可以回答问题。它可以通过向银行支付资金或通过控制工厂中的机器人手臂来影响世界。我们用来召唤计算过程的程序就像魔法师的法术，它们是由神秘和深奥的编程语言中的符号表达式精心组成的，它们定义了我们希望我们的计算过程执行的任务。

在正确工作的计算机中，计算过程精确且准确地执行程序。因此，像巫师的学徒一样，新手程序员必须学会理解并预测他们魔术的后果。程序中非常小的错误都可能导致复杂的或者不可预见的后果。

幸运的是，学习编程比学习巫术要安全的多，因为我们处理的精神很方便地以安全的方式被包裹。然而真实世界的程序，仍然要求谨慎，专业和智慧。例如，计算机辅助设计程序中的一个小错误可能导致飞机或大坝的灾难性崩溃或工业机器人的自毁。

软件工程大师们有组织程序的能力，以至于他们有理由相信程序会按照他们设想的任务完成得到他们想要的结果。他们可以提前预见他们系统的行为。他们知道如果构建程序以避免不可预见的问题不会导致灾难性后果，当问题出现时，他们知道如何调试程序。

良好设计的计算系统，像是自动飞行或者核电站反应堆，都是以模块的方式设计出来的，模块可以独立的被构建，替换和调试。

Lisp编程
我们需要核实的语言描述计算过程，我们打算使用编程语言Lisp。 就像我们每天的想法通常通过自然语言表达，定量现象的描述是
用数学符号表达，我们的程序思想将用Lisp表达。Lisp是在20世纪50年代后期发明出来的计算模型，用于推理使用某些逻辑的形式表达式，称为递归方程。
尽管Lisp内在是一种数学公式，但它是一种实用的编程语言。

如果Lisp不是主流语言，为什么我们使用它作为我们讨论编程的框架？因为Lisp语言拥有独特的功能，使其成为研究重要的编程结构和数据结构以及将它们与支持它们的语言特征相关联的极好媒介。这些功能中最重要的是Lisp对进程的描述，称为程序(procedure)，procedure可以自己作为Lisp数据进行表示和操作。这一点的重要性在于，有强大的程序设计技术依赖于模糊“被动”数据和“主动”过程之间传统区别的能力。正如我们将要发现的那样，Lisp作为数据处理程序的灵活性使其成为最方便的语言之一去探索这些技术的存在。将程序表示为数据的能力也使Lisp成为一种出色的语言，用于编写必须将其他程序作为数据操作的程序，例如支持计算机语言的口译员和编译器。除了这些考虑之外，在Lisp中编程非常有趣。

1.1 程序的组成
一个功能强大的编程语言不只是一种指示计算机完成任务的方法，语言本身也是我们组织过程想法的框架。因此，当我们描述语言，我们需要特别注意，语言所提供的把简单想法组合形成复杂逻辑的方法。做到这些，每个功能强大的语言都有这三个部分：
a. 原子表达式：用于表达最简单的实体
b. 组合方式： 从简单的实体构建复合的元素
c. 抽象方式： 复合元素可以作为单元被命名和操作

在程序中，我们处理两类元素：过程和数据。 数据是我们想要操作的对象，过程用于描述操作数据的规则。因此，任何功能强大的编程语言要能够描述原子数据和原子过程，并且能够组合和抽象数据和过程。

1.1.1 表达式
数字是一种原子表达式。比如486，编译器会打印出486.
数字表达式可能是由一个原子过程（比如➕或者*）构建的复合表达式，这个复合表达式描述了过程作用于数字的应用。比如
（+ 137 349）
486

前缀表示法的好处：
接受任意个数的参数 (+ 21 35 12 7)
没有二义性，组合可以嵌套： (+ (* 3 5) (- 10 6))

解释器运行方式： read-eval-print 模式

1.1.2 命名和环境
定义变量（最简单的一种抽象方式），容许我们用一种简单的代号指代一个组合的操作结果，比如圆周率：  define size 2
解释器用于保存和维护name-object对的内存我们称之为环境。环境定义了基本概念，也称之为上下文

1.1.3 计算组合表达式
递归：
1. 计算子表达式： 
    最底层的原子表达式： 例如数字，内置操作符，或者别的变量名：
      处理原子表达式方式：
        1. 数字的值就是他们的名字；
        2. 内置的符号值就是他们代表的相应操作的指导过程
        3. 别的变量的值是环境中所关联的这些名字的对象的值      
2. 计算值： 最左边的表达式，作用于其他的操作数： 复合表达式的计算：实际上，评估规则的“渗透值向上”形式是一种称为树积累的一般过程的例子。
3. define x 2 不是复合表达式，他是把x和2关联起来，我们称之为特别的格式） special forms

1.1.4 组合过程
过程定义： 抽象技术： 一个复合的操作可以被赋予变量名，作为一个单元的引用 （name和复合操作的关联）
The general form of a procedure definition is :
   (define (<name> <formal parameters>) <body>): for example: 
   (define (square x) (* x x))

使用过程定义的例子： （square （ + 2 5））
我们也可以使用square作为构造模块用在别的过程定义中，例如：
x^2 + y^2 : (+ square x) (square y))
我们可以很容易定义一个求平方和的过程：
（define (sum-of-square x y)
   (+ (square x) (square y))
 : 
 
 (sum-of-square 3 4)  
 25
 
 我们又可以使用sum-of-square 去构建更多的过程定义：
 
 （define (f a)
    (sum-of-squares (+ a 1) (+ a 2)))
  :
  
  f(5)
  136
  
 复合过程和原子过程的使用方式是完全一样，事实上，当你看到sum-of-squares的定义的时候，你是没办法很好的区分squares在编译器里面是像+，* 一样是原子表达式，还是复合表达式。
 

1.1.5 程序的替换模型
解释器计算复合过程的方式跟计算复合表达式的过程是一样的。
解释器会计算复合过程的元素，把过程应用到参数上（如同表达式把操作符作用于操作数）

处理的过程：
  把复合过程应用到参数上，计算过程的主体，其中每个正式的参数会被相应的参数值替换。
  
例如

(f 5) --> 
(sum-of-squares (+ a 1) (* a 2))
--> 
(sum-of-squares (+ 5 1) (* 5 2))
--> 
(sum-of-squares 6 10)
-->
(+ (squares 6) (square 10))
-->
( + (* 6 6) (* 10 10))
--> 
(+ 36 100)
--> 136

有两点需要注意：
1. 替换模型只是帮助我们思考过程应用，编译器并不是真的按照这种方式工作。典型的编译器不会操控过程文本去替换参数的值，实际中替换是在上下文中完成的。我们会在第三第四章详细的解释细节。
2. 替换模型只是一个简单的，不完整的模型，不适用于复杂的工程场景。当我们进一步观察事物的细节时，替换模型变的不再适用，我们会在第三章实用“可变数据” 过程，我们会用更复杂的模型替换“替换模型”。

Applicative order vs normal ordere
另外一种解释器的工作方式：
  先替换所有的操作数，直到得到一个表达式中只有原子操作数，然后再完成计算过程.
  (f 5)
  --> 
  (sum-of-squars (+ 5 1)(* 5 2))
  --->
  (+ (square (+ 5 1)) square (* 5 2)) )
  --->
  (+ (* (+ 5 1)(+5 1)) (* (* 5 2）（* 5 2）））
  ---->
  (+  (* 6 6)(* 10 10))
  --->
  (+ 36 100)
  --> 
  136
  
  先充分扩展再回溯计算的方法被称为 normal-order
  
 计算参数再应用参数的方法被称为 applicative-order
 
 Lisp使用applicative-order计算模型
 
 
1.1.6 条件表达式和谓词




