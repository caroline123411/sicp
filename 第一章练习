Ex 1.1 
10 --》 10
（+ 5 3 4） --》 12
（- 9 1） --》 8
（/ 6 2） --》 3
(+ (* 2 4 ) (-4 6)) --> 6
(define a 3) --> a 3
(define b (+ a 1)) --> b 4
(+ a b (* a b)) --> (+ 3 4 (* 3 4)) --> (+ 3 4 12) --> 19
(= a b) ---> false
(if (and (> b a) (< b (*a b)))
    b
    a)  --> 4
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
----> 16
(+ 2 (if (> b a) b a))
---> 6
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
---> 
(* 4 4) --> 16

Ex 1.2 
(5+4+(2-(3-(6+4/5))))/(3*(6-2)*(2-7))
prefix form:
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))  (* 3 (- 6 2) (- 2 7)))

Ex 1.3
(define sum-of-squares x y)
   (+ (* x x) (* y y))

(define >= x y)
  ( or (> x y) (x = y))

(define max-two-larger-squares x y z)
  (cond ((and (>= x z) (>= y z)) (sum-of-squares x y))
        ((and (>= x y) (>= z y)) (sum-of-squares x z))
        ((and (>= y x) (>= z x)) (sum-of-squares y z)))
        (
Ex1.4
if b> 0 return a + b
else return a - b

Ex 1.5
applicative order:  (test 0 (p)) --> 0 
normal order: (test 0 (p)) ---> (test 0 (p)) .... dead loop

Ex 1.6

(define (sqrt-iter guess x)
  (new-if good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
                     
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
                     
new-if will return a value : (sqrt-iter (improve guess x) x)

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

